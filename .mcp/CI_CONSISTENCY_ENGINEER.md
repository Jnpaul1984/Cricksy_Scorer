# CI Consistency Engineer (MCP Protocol)

## Critical Fix: Environment Variables for Test Workflows

**IMPORTANT**: All GitHub Actions workflows that run backend tests MUST set these three environment variables in their test steps:

```yaml
env:
  CRICKSY_IN_MEMORY_DB: "1"
  DATABASE_URL: "sqlite+aiosqlite:///:memory:?cache=shared"
  APP_SECRET_KEY: "test-secret-key"
```

###  Why This Matters

The application uses Pydantic Settings which reads environment variables **at import time** when creating the global `settings` object. If `CRICKSY_IN_MEMORY_DB` is not explicitly set:

1. The `backend/config.py` Settings object is instantiated early (when first imported)
2. `settings.IN_MEMORY_DB` defaults to `False` (no env var present)
3. Later, `backend/tests/_ci_utils.py` may auto-detect and set the env var
4. **BUT** the Settings object was already created with `IN_MEMORY_DB=False`
5. This causes tests to try using PostgreSQL instead of in-memory SQLite
6. Results in auth failures (401) and other unpredictable test behavior

### SQLAlchemy Session Configuration

All `async_sessionmaker` instances MUST include `expire_on_commit=False`:

```python
session_local = async_sessionmaker(
    bind=eng,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False,  # ← CRITICAL: Prevents MissingGreenlet errors
)
```

This setting prevents ORM objects from expiring after `session.commit()`, which would trigger lazy loading in async contexts and cause `MissingGreenlet` errors or 401 auth failures.

See `.mcp/SQLALCHEMY_ASYNC_BEST_PRACTICES.md` Rule 0 for details.

---

## Mission
Guarantee deterministic CI: **Any change that passes locally using the CI entrypoint must pass on GitHub Actions.**
If GitHub fails while local passes, treat it as an **engineering defect** and resolve via diagnosis + parity, not guesswork.

---

## Non-Negotiables (Hard Rules)

### PRE-COMMIT VALIDATION (MANDATORY)
**CRITICAL**: Before ANY commit or push, run ALL of these commands locally:

```powershell
# Backend (from backend/ directory)
cd backend

# 1. Type checking (mypy)
$env:PYTHONPATH = "C:\Users\Hp\Cricksy_Scorer"
mypy --config-file pyproject.toml --explicit-package-bases .

# 2. Linting (ruff)
ruff check .

# 3. Format check
ruff format --check .

# 4. Tests with coverage
$env:CRICKSY_IN_MEMORY_DB = "1"
$env:DATABASE_URL = "sqlite+aiosqlite:///:memory:?cache=shared"
$env:APP_SECRET_KEY = "test-secret-key"
pytest tests/ -q

# 5. Pre-commit hooks (ALL files)
cd ..
pre-commit run --all-files
```

**If ANY of these fail, DO NOT commit. Fix the errors first.**

1. **Single Source of Truth Command**
   - CI must run exactly one entrypoint (choose one):
     - `make ci` (preferred), OR
     - `./scripts/ci.sh`, OR
     - `npm run ci` + `python -m ...` wrapper
   - Local developers must be able to run the exact same entrypoint.

2. **Pinned Runtime Versions**
   - Python: pinned via `.python-version` and mirrored in GitHub Actions `setup-python`.
   - Node: pinned via `.nvmrc` (or `.tool-versions`) and mirrored in `setup-node`.
   - Never use "latest" in CI for languages or actions unless explicitly justified.

3. **Deterministic Dependencies**
   - Python must use one of:
     - `uv.lock` (uv), OR
     - `requirements.txt` generated by pip-tools (fully pinned; ideally hashes)
   - Node must use exactly one lockfile:
     - `package-lock.json` (npm ci), OR
     - `pnpm-lock.yaml` (pnpm --frozen-lockfile), OR
     - `yarn.lock` (yarn --immutable)
   - CI must use the deterministic install mode (`npm ci`, `pnpm i --frozen-lockfile`, etc.).

4. **No Silent Drift**
   - If workflow steps run commands not used locally, it is a bug.
   - If local instructions differ from CI, update docs and/or scripts until identical.

5. **No Flaky Tests Allowed**
   - Tests must be deterministic:
     - fixed seeds for RNG where relevant
     - no network calls (mock them)
     - stable ordering (don't depend on filesystem order)
     - reasonable timeouts
   - If a test is flaky, fix it or quarantine it with an issue + expiration date.

---

## CI Design Standards
### Workflow Triggers (avoid wasted runs)
- Default:
  - `pull_request` for fast checks
  - `push` on protected branches only (e.g., `main`)
- Heavy jobs:
  - run only on `push` to `main` OR `workflow_dispatch`
- Add `paths-ignore` for docs-only changes where safe.

### Concurrency
- Use:
  - `concurrency: group: ${{ github.workflow }}-${{ github.ref }}`
  - `cancel-in-progress: true`

### Caching (safe caching only)
- Cache keys must include:
  - OS
  - runtime version
  - lockfile hash
- Never cache mutable envs in a way that bypasses lockfiles.

### Services (Postgres/Redis/etc.)
- Define as workflow `services:` with:
  - health checks
  - explicit ports
- Add a wait step (health probe) before running tests.

---

## Required Repo Files/Conventions
- Provide one canonical CI entrypoint:
  - `Makefile` target: `ci` runs lint + unit tests + type checks (fast).
  - Optional: `ci-full` runs integration/e2e (heavy).
- Provide a `CONTRIBUTING.md` section:
  - "Run what CI runs" → `make ci`
- Provide `.env.example` for required env vars (no secrets).

---

## Diagnosis Playbook (when CI fails but local passes)
1. **Confirm the failing command**
   - Identify the exact step/command that failed in Actions logs.

2. **Dump Environment Parity**
   - Log (redacting secrets):
     - OS + uname
     - python/node versions
     - dependency manager versions
     - lockfile presence + checksum
     - working directory + relevant tree
   - If services used: log connectivity check.

3. **Classify Root Cause**
   - Version drift → pin it.
   - Dependency drift → lock it.
   - Missing system deps → install it (apt-get) and document.
   - Flakiness → seed, mock, reorder, fix timing.
   - Permissions/secrets → correct Actions permissions and env var wiring.

4. **Fix by Parity**
   - Fix must move CI toward local parity, not "special CI behavior".
   - Update entrypoint scripts so local and CI stay identical.

5. **Add Regression Guardrails**
   - Add a check that fails CI if:
     - lockfiles missing
     - runtime versions not pinned
     - CI is not using the canonical entrypoint

---

## Implementation Checklist for Any CI Change
- [ ] **RAN ALL PRE-COMMIT CHECKS LOCALLY** (mypy, ruff, ruff format, pytest, pre-commit)
- [ ] **VERIFIED ALL CHECKS PASS** before committing
- [ ] CI calls the canonical entrypoint only
- [ ] Python version pinned and consistent
- [ ] Node version pinned and consistent
- [ ] Lockfiles enforced; deterministic install used
- [ ] Caches keyed on lockfiles + runtime versions
- [ ] Services have health checks + wait step
- [ ] Tests deterministic (no flakiness)
- [ ] Concurrency + path filters in place
- [ ] Docs updated: dev runs same commands as CI

## Agent Pre-Commit Protocol

When an AI agent makes code changes, it MUST:

1. **BEFORE any git commit/push operations:**
   - Run `mypy` on changed files
   - Run `ruff check` on changed files
   - Run `ruff format --check` on changed files
   - Run relevant `pytest` tests (minimum: affected test files)
   - Run `pre-commit run --all-files` if hooks are configured

2. **NEVER commit if ANY check fails:**
   - Fix errors immediately
   - Re-run all checks after fixes
   - Only proceed to commit when ALL checks pass

3. **Document what was run:**
   - Include in commit message: "Tested: [commands run]"
   - Example: "Tested: mypy, ruff, pytest tests/test_mediapipe_concurrency.py"

**VIOLATION CONSEQUENCE**: If GitHub Actions fails on checks that should have been run locally, this is a CRITICAL AGENT ERROR. The agent must:
- Immediately acknowledge the failure
- Fix all errors
- Re-run ALL local checks
- Update this document if new checks need to be added
- Create a fixup commit with all corrections
