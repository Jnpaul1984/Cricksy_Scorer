name: Deploy Backend

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  test-backend-postgres:
    name: Test Backend (Postgres)
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: cricksy
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U test -d cricksy"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    env:
      DATABASE_URL: postgresql+asyncpg://test:test@localhost:5432/cricksy
      APP_SECRET_KEY: ${{ secrets.APP_SECRET_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: backend/requirements.txt

      - name: Install backend dependencies
        working-directory: .
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Run Alembic migrations
        working-directory: .
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          PYTHONPATH: ${{ github.workspace }}/backend
        run: |
          alembic -c backend/alembic.ini upgrade head

      - name: Run backend tests
        working-directory: .
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          PYTHONPATH: ${{ github.workspace }}/backend/backend
        run: |
          pytest -v

  build-and-scan:
    name: Build and Scan ECR Image
    runs-on: ubuntu-latest
    needs: [test-backend-postgres]
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 365183982031
      ECR_REPOSITORY: cricksy-backend
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build deterministic image tag
        id: tag
        run: |
          SHORT_SHA=${GITHUB_SHA:0:12}
          TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Image tag: ${IMAGE_TAG}"

      - name: Build backend image
        working-directory: .
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          docker build -f backend/Dockerfile -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest

      - name: Push backend image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest

      - name: Scan ECR image for vulnerabilities
        id: scan
        env:
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          echo "Starting image scan for tag: $IMAGE_TAG"
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }}

          echo "Waiting for scan to complete..."
          for i in {1..30}; do
            STATUS=$(aws ecr describe-image-scan-findings \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --image-id imageTag=$IMAGE_TAG \
              --region ${{ env.AWS_REGION }} \
              --output json | jq -r '.imageScanStatus.status')

            echo "Attempt $i: Scan status is $STATUS"

            if [ "$STATUS" = "COMPLETE" ]; then
              echo "Scan completed successfully"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "Scan failed"
              exit 1
            fi

            if [ "$i" -eq 30 ]; then
              echo "Scan did not complete in time"
              exit 1
            fi

            sleep 10
          done

          echo "Retrieving scan findings..."
          FINDINGS=$(aws ecr describe-image-scan-findings \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} \
            --output json)

          echo "Full scan findings:"
          echo "$FINDINGS"

          NON_KERNEL=$(echo "$FINDINGS" | jq '.imageScanFindings.findings[]
            | select(.attributes | any(.key=="package_name" and .value!="linux"))')

          HIGH_COUNT=$(echo "$NON_KERNEL" | jq '[.[] | select(.severity=="HIGH")] | length' 2>/dev/null || echo 0)
          CRITICAL_COUNT=$(echo "$NON_KERNEL" | jq '[.[] | select(.severity=="CRITICAL")] | length' 2>/dev/null || echo 0)

          echo "Non-kernel HIGH count: $HIGH_COUNT"
          echo "Non-kernel CRITICAL count: $CRITICAL_COUNT"

          if [ "$HIGH_COUNT" -gt 0 ] || [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "::error::Build failed due to non-kernel HIGH/CRITICAL vulnerabilities."
            exit 1
          else
            echo "âœ… No blocking non-kernel vulnerabilities found."
          fi


  deploy:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    env:
      AWS_REGION: us-east-1
      ECR_REPOSITORY: cricksy-backend
      ECS_CLUSTER: cricksy-ai-cluster
      ECS_SERVICE: cricksy-ai-backend-service

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Force new ECS deployment
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment

      - name: Wait for service to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Dump ECS events and stopped tasks
        if: failure()
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER: ${{ env.ECS_CLUSTER }}
          ECS_SERVICE: ${{ env.ECS_SERVICE }}
          LOG_GROUP: /cricksy-ai/api
        run: |
          set -euo pipefail

          echo "=== ECS service events ==="
          aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].events' --output json || true

          echo
          echo "=== Current service summary (taskDefinition, deployments) ==="
          aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].[taskDefinition,deployments]' --output json || true

          echo
          echo "=== Stopped tasks for service ==="
          STOPPED_TASKS=$(aws ecs list-tasks \
            --cluster "$ECS_CLUSTER" \
            --service-name "$ECS_SERVICE" \
            --desired-status STOPPED \
            --region "$AWS_REGION" \
            --output text --query 'taskArns' || true)

          if [ -z "${STOPPED_TASKS:-}" ] || [ "${STOPPED_TASKS}" = "None" ]; then
            echo "No stopped tasks found"
          else
            echo "Stopped task ARNs: $STOPPED_TASKS"
            echo
            echo "=== Describe stopped tasks (stoppedReason, exitCode, containers) ==="
            aws ecs describe-tasks \
              --cluster "$ECS_CLUSTER" \
              --tasks $STOPPED_TASKS \
              --region "$AWS_REGION" \
              --query 'tasks[*].{Arn:taskArn,LastStatus:lastStatus,StoppedReason:stoppedReason,Containers:containers[*].{Name:name,ExitCode:exitCode,Reason:reason}}' --output json || true
          fi

          echo
          echo "=== Task definition & logConfiguration ==="
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].taskDefinition' --output text || true)

          if [ -n "$TASK_DEF_ARN" ] && [ "$TASK_DEF_ARN" != "None" ]; then
            echo "Task Definition ARN: $TASK_DEF_ARN"
            aws ecs describe-task-definition \
              --task-definition "$TASK_DEF_ARN" \
              --region "$AWS_REGION" \
              --query 'taskDefinition.containerDefinitions[*].{Name:name,LogConfiguration:logConfiguration}' --output json || true

            echo
            echo "=== CloudWatch log streams for log group: $LOG_GROUP ==="
            if [ -n "${STOPPED_TASKS:-}" ] && [ "${STOPPED_TASKS}" != "None" ]; then
              for arn in $STOPPED_TASKS; do
                task_id=${arn##*/}
                echo "Log streams for task $task_id:"
                aws logs describe-log-streams \
                  --log-group-name "$LOG_GROUP" \
                  --log-stream-name-prefix "$task_id" \
                  --region "$AWS_REGION" \
                  --output json || true
              done
            else
              echo "No stopped tasks to query log streams for"
            fi
          else
            echo "No taskDefinition ARN found for the service."
          fi
