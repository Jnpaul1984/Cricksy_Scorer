name: Deploy Backend

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  test-backend-postgres:
    name: Test Backend (Postgres)
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: cricksy
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U test -d cricksy"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    env:
      DATABASE_URL: postgresql+asyncpg://test:test@localhost:5432/cricksy
      APP_SECRET_KEY: ${{ secrets.APP_SECRET_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: backend/requirements.txt

      - name: Install backend dependencies
        working-directory: .
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Run Alembic migrations
        working-directory: .
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          PYTHONPATH: ${{ github.workspace }}
        run: |
          alembic -c backend/alembic.ini upgrade head

      - name: Run backend tests
        working-directory: .
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pytest -v

  build-and-scan:
    name: Build and Scan ECR Image
    runs-on: ubuntu-latest
    needs: [test-backend-postgres]
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 365183982031
      ECR_REPOSITORY: cricksy-backend
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build deterministic image tag
        id: tag
        run: |
          SHORT_SHA=${GITHUB_SHA:0:12}
          TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Image tag: ${IMAGE_TAG}"

      - name: Build backend image
        working-directory: .
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          docker build -f backend/Dockerfile -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest

      - name: Push backend image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest

      - name: Scan ECR image for vulnerabilities
        id: scan
        env:
          IMAGE_TAG: ${{ steps.tag.outputs.image_tag }}
        run: |
          echo "Starting image scan for tag: $IMAGE_TAG"
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }}

          echo "Waiting for scan to complete..."
          for i in {1..30}; do
            STATUS=$(aws ecr describe-image-scan-findings \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --image-id imageTag=$IMAGE_TAG \
              --region ${{ env.AWS_REGION }} \
              --output json | jq -r '.imageScanStatus.status')

            echo "Attempt $i: Scan status is $STATUS"

            if [ "$STATUS" = "COMPLETE" ]; then
              echo "Scan completed successfully"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "Scan failed"
              exit 1
            fi

            if [ "$i" -eq 30 ]; then
              echo "Scan did not complete in time"
              exit 1
            fi

            sleep 10
          done

          echo "Retrieving scan findings..."
          FINDINGS=$(aws ecr describe-image-scan-findings \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} \
            --output json)

          echo "Full scan findings:"
          echo "$FINDINGS"

          NON_KERNEL=$(echo "$FINDINGS" | jq '.imageScanFindings.findings[]
            | select(.attributes | any(.key=="package_name" and .value!="linux"))')

          HIGH_COUNT=$(echo "$NON_KERNEL" | jq '[.[] | select(.severity=="HIGH")] | length' 2>/dev/null || echo 0)
          CRITICAL_COUNT=$(echo "$NON_KERNEL" | jq '[.[] | select(.severity=="CRITICAL")] | length' 2>/dev/null || echo 0)

          echo "Non-kernel HIGH count: $HIGH_COUNT"
          echo "Non-kernel CRITICAL count: $CRITICAL_COUNT"

          if [ "$HIGH_COUNT" -gt 0 ] || [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "::error::Build failed due to non-kernel HIGH/CRITICAL vulnerabilities."
            exit 1
          else
            echo "✅ No blocking non-kernel vulnerabilities found."
          fi


  deploy:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: 365183982031
      ECR_REPOSITORY: cricksy-backend
      ECS_CLUSTER: cricksy-ai-cluster
      ECS_SERVICE: cricksy-ai-backend-service
      ECS_WORKER_SERVICE: cricksy-ai-worker-service

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch current task definition and update image
        id: task-def
        run: |
          # Get task definition ARN from the service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "Task definition ARN: $TASK_DEF_ARN"

          # Describe the task definition
          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json > task-definition-raw.json

          # Get the container name from the task definition
          CONTAINER_NAME=$(jq -r '.containerDefinitions[0].name' task-definition-raw.json)
          echo "Container name: $CONTAINER_NAME"
          echo "container_name=$CONTAINER_NAME" >> $GITHUB_OUTPUT

          # Update the image in the task definition
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-scan.outputs.image_tag }}"
          echo "New image: $NEW_IMAGE"
          echo "new_image=$NEW_IMAGE" >> $GITHUB_OUTPUT

          # Filter out metadata fields that register-task-definition doesn't accept
          jq --arg IMAGE "$NEW_IMAGE" --arg CONTAINER "$CONTAINER_NAME" \
            'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
             .containerDefinitions |= map(if .name == $CONTAINER then .image = $IMAGE else . end)' \
            task-definition-raw.json > task-definition.json

          echo "Updated task definition:"
          jq '.containerDefinitions[0] | {name, image}' task-definition.json

      - name: Register new backend task definition
        id: register
        run: |
          set -euo pipefail

          REGISTER_OUTPUT=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --region "${{ env.AWS_REGION }}")

          NEW_TASK_DEF_ARN=$(echo "$REGISTER_OUTPUT" | jq -r '.taskDefinition.taskDefinitionArn')
          if [ -z "$NEW_TASK_DEF_ARN" ] || [ "$NEW_TASK_DEF_ARN" = "null" ]; then
            echo "::error::Failed to register backend task definition"
            echo "$REGISTER_OUTPUT" | jq -r '.' || true
            exit 1
          fi

          echo "Registered new backend task definition: $NEW_TASK_DEF_ARN"
          echo "task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Run DB migrations (one-off ECS task)
        env:
          CONTAINER_NAME: ${{ steps.task-def.outputs.container_name }}
          NEW_TASK_DEF_ARN: ${{ steps.register.outputs.task_def_arn }}
        run: |
          set -euo pipefail

          CLUSTER="${{ env.ECS_CLUSTER }}"
          SERVICE="${{ env.ECS_SERVICE }}"
          REGION="${{ env.AWS_REGION }}"
          TASK_DEF_ARN="$NEW_TASK_DEF_ARN"
          CONTAINER="$CONTAINER_NAME"

          echo "Fetching network configuration from service: $SERVICE"
          SVC_JSON=$(aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --region "$REGION" \
            --output json)

          AWSPVC=$(echo "$SVC_JSON" | jq -c '.services[0].networkConfiguration.awsvpcConfiguration')
          PLATFORM=$(echo "$SVC_JSON" | jq -r '.services[0].platformVersion // "LATEST"')
          SUBNETS=$(echo "$AWSPVC" | jq -r '.subnets | join(",")')
          SECGROUPS=$(echo "$AWSPVC" | jq -r '.securityGroups | join(",")')
          ASSIGN_PUBLIC_IP=$(echo "$AWSPVC" | jq -r '.assignPublicIp // "DISABLED"')

          if [ -z "$SUBNETS" ] || [ "$SUBNETS" = "null" ]; then
            echo "::error::Could not determine subnets from ECS service network configuration"
            echo "$SVC_JSON" | jq -r '.' || true
            exit 1
          fi
          if [ -z "$SECGROUPS" ] || [ "$SECGROUPS" = "null" ]; then
            echo "::error::Could not determine security groups from ECS service network configuration"
            echo "$SVC_JSON" | jq -r '.' || true
            exit 1
          fi

          echo "Running migration task using task definition: $TASK_DEF_ARN"
          echo "Platform version: $PLATFORM"
          echo "Subnets: $SUBNETS"
          echo "SecurityGroups: $SECGROUPS"
          echo "AssignPublicIp: $ASSIGN_PUBLIC_IP"

          OVERRIDES=$(jq -c -n --arg CN "$CONTAINER" '{containerOverrides:[{name:$CN,environment:[{name:"MIGRATE_ONLY",value:"true"}]}]}')

          TASK_ARN=$(aws ecs run-task \
            --cluster "$CLUSTER" \
            --task-definition "$TASK_DEF_ARN" \
            --launch-type FARGATE \
            --platform-version "$PLATFORM" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECGROUPS],assignPublicIp=$ASSIGN_PUBLIC_IP}" \
            --overrides "$OVERRIDES" \
            --started-by "github-actions-migrate" \
            --region "$REGION" \
            --query 'tasks[0].taskArn' \
            --output text)

          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "::error::Failed to start migration task"
            aws ecs run-task \
              --cluster "$CLUSTER" \
              --task-definition "$TASK_DEF_ARN" \
              --launch-type FARGATE \
              --platform-version "$PLATFORM" \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECGROUPS],assignPublicIp=$ASSIGN_PUBLIC_IP}" \
              --overrides "$OVERRIDES" \
              --started-by "github-actions-migrate" \
              --region "$REGION" \
              --output json | jq -r '.'
            exit 1
          fi

          echo "Migration task started: $TASK_ARN"
          aws ecs wait tasks-stopped --cluster "$CLUSTER" --tasks "$TASK_ARN" --region "$REGION"

          DESC=$(aws ecs describe-tasks --cluster "$CLUSTER" --tasks "$TASK_ARN" --region "$REGION" --output json)
          EXIT_CODE=$(echo "$DESC" | jq -r '.tasks[0].containers[0].exitCode // -1')
          STOPPED_REASON=$(echo "$DESC" | jq -r '.tasks[0].stoppedReason // ""')
          CONTAINER_REASON=$(echo "$DESC" | jq -r '.tasks[0].containers[0].reason // ""')

          echo "Migration task exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" != "0" ]; then
            echo "::error::Migration task failed. stoppedReason=$STOPPED_REASON reason=$CONTAINER_REASON"
            echo "$DESC" | jq -r '.tasks[0] | {taskArn,lastStatus,stoppedReason,containers}'
            exit 1
          fi

          echo "✓ Migrations completed successfully"

      - name: Deploy backend service (update ECS service)
        id: deploy
        env:
          NEW_TASK_DEF_ARN: ${{ steps.register.outputs.task_def_arn }}
        run: |
          set -euo pipefail
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --force-new-deployment

      - name: Wait for service to stabilize
        run: |
          set -e
          CLUSTER="${{ env.ECS_CLUSTER }}"
          SERVICE="${{ env.ECS_SERVICE }}"
          REGION="${{ env.AWS_REGION }}"
          MAX_ATTEMPTS=60
          ATTEMPT=0

          echo "Waiting for ECS service to stabilize (max ${MAX_ATTEMPTS} × 15s)..."

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            # Get service status
            STATUS=$(aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --region "$REGION" \
              --query 'services[0].[runningCount,desiredCount,deployments[0].status]' \
              --output text 2>/dev/null || echo "ERROR")

            if [ "$STATUS" = "ERROR" ]; then
              echo "[$ATTEMPT/$MAX_ATTEMPTS] Failed to get service status, retrying..."
              sleep 15
              continue
            fi

            RUNNING=$(echo "$STATUS" | awk '{print $1}')
            DESIRED=$(echo "$STATUS" | awk '{print $2}')
            DEPLOYMENT_STATUS=$(echo "$STATUS" | awk '{print $3}')

            echo "[$ATTEMPT/$MAX_ATTEMPTS] Running: $RUNNING, Desired: $DESIRED, Deployment: $DEPLOYMENT_STATUS"

            # Service is stable when running equals desired and deployment is PRIMARY
            if [ "$RUNNING" -eq "$DESIRED" ] && [ "$DEPLOYMENT_STATUS" = "PRIMARY" ]; then
              echo "✓ Service is stable!"
              exit 0
            fi

            # Check for stopped tasks with errors
            if [ $((ATTEMPT % 4)) -eq 0 ]; then
              echo "  [DEBUG] Checking for stopped tasks..."
              STOPPED_TASKS=$(aws ecs list-tasks \
                --cluster "$CLUSTER" \
                --service-name "$SERVICE" \
                --desired-status STOPPED \
                --region "$REGION" \
                --output text --query 'taskArns[:2]' 2>/dev/null || true)

              if [ -n "${STOPPED_TASKS}" ] && [ "${STOPPED_TASKS}" != "None" ]; then
                echo "  [DEBUG] Found stopped tasks, checking details..."
                aws ecs describe-tasks \
                  --cluster "$CLUSTER" \
                  --tasks $STOPPED_TASKS \
                  --region "$REGION" \
                  --query 'tasks[*].[taskArn,lastStatus,stoppedReason]' \
                  --output table 2>/dev/null || true
              fi
            fi

            sleep 15
          done

          echo "✗ Service failed to stabilize after ${MAX_ATTEMPTS} attempts"
          echo ""
          echo "=== Service Status ==="
          aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --region "$REGION" \
            --query 'services[0].[serviceName,status,runningCount,desiredCount,deployments[*].[status,runningCount,desiredCount,taskDefinition]]' \
            --output table

          echo ""
          echo "=== Stopped Tasks ==="
          aws ecs list-tasks \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE" \
            --desired-status STOPPED \
            --region "$REGION" \
            --output text --query 'taskArns' 2>/dev/null | xargs -I {} aws ecs describe-tasks \
            --cluster "$CLUSTER" \
            --tasks {} \
            --region "$REGION" \
            --query 'tasks[*].[taskArn,lastStatus,stoppedReason,containers[0].exitCode,containers[0].reason]' \
            --output table 2>/dev/null || echo "No stopped tasks or error fetching details"

          exit 1

      - name: Deploy analysis worker service (same image, worker command)
        env:
          NEW_IMAGE: ${{ steps.task-def.outputs.new_image }}
        run: |
          set -euo pipefail

          CLUSTER="${{ env.ECS_CLUSTER }}"
          SERVICE="${{ env.ECS_WORKER_SERVICE }}"
          REGION="${{ env.AWS_REGION }}"

          echo "Deploying worker service: $SERVICE"

          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --region "$REGION" \
            --query 'services[0].taskDefinition' \
            --output text)

          if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" = "None" ]; then
            echo "::error::Could not find taskDefinition for worker service $SERVICE"
            exit 1
          fi

          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --region "$REGION" \
            --query 'taskDefinition' \
            --output json > worker-task-definition-raw.json

          WORKER_CONTAINER=$(jq -r '.containerDefinitions[0].name' worker-task-definition-raw.json)
          echo "Worker container name: $WORKER_CONTAINER"

          jq --arg IMAGE "$NEW_IMAGE" --arg CONTAINER "$WORKER_CONTAINER" \
            'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
             .containerDefinitions |= map(
               if .name == $CONTAINER then
                 (.image = $IMAGE) |
                 (.command = ["python","-m","backend.workers.analysis_worker"])
               else . end
             )' \
            worker-task-definition-raw.json > worker-task-definition.json

          echo "Registering updated worker task definition..."
          REGISTER_OUTPUT=$(aws ecs register-task-definition \
            --cli-input-json file://worker-task-definition.json \
            --region "$REGION")

          NEW_WORKER_TASK_DEF_ARN=$(echo "$REGISTER_OUTPUT" | jq -r '.taskDefinition.taskDefinitionArn')
          if [ -z "$NEW_WORKER_TASK_DEF_ARN" ] || [ "$NEW_WORKER_TASK_DEF_ARN" = "null" ]; then
            echo "::error::Failed to register worker task definition"
            echo "$REGISTER_OUTPUT" | jq -r '.' || true
            exit 1
          fi

          echo "Updating worker service to new task definition: $NEW_WORKER_TASK_DEF_ARN"
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_WORKER_TASK_DEF_ARN" \
            --region "$REGION" \
            --force-new-deployment

          echo "Waiting for worker service to stabilize..."
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE" --region "$REGION"
          echo "✓ Worker service deployed and stable"

      - name: Dump ECS events and stopped tasks
        if: failure()
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER: ${{ env.ECS_CLUSTER }}
          ECS_SERVICE: ${{ env.ECS_SERVICE }}
          LOG_GROUP: /cricksy-ai/api
        run: |
          set -euo pipefail

          echo "=== ECS service events ==="
          aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].events' --output json || true

          echo
          echo "=== Current service summary (taskDefinition, deployments) ==="
          aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].[taskDefinition,deployments]' --output json || true

          echo
          echo "=== Stopped tasks for service ==="
          STOPPED_TASKS=$(aws ecs list-tasks \
            --cluster "$ECS_CLUSTER" \
            --service-name "$ECS_SERVICE" \
            --desired-status STOPPED \
            --region "$AWS_REGION" \
            --output text --query 'taskArns' || true)

          if [ -z "${STOPPED_TASKS:-}" ] || [ "${STOPPED_TASKS}" = "None" ]; then
            echo "No stopped tasks found"
          else
            echo "Stopped task ARNs: $STOPPED_TASKS"
            echo
            echo "=== Describe stopped tasks (stoppedReason, exitCode, containers) ==="
            aws ecs describe-tasks \
              --cluster "$ECS_CLUSTER" \
              --tasks $STOPPED_TASKS \
              --region "$AWS_REGION" \
              --query 'tasks[*].{Arn:taskArn,LastStatus:lastStatus,StoppedReason:stoppedReason,Containers:containers[*].{Name:name,ExitCode:exitCode,Reason:reason}}' --output json || true
          fi

          echo
          echo "=== Task definition & logConfiguration ==="
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --region "$AWS_REGION" \
            --query 'services[0].taskDefinition' --output text || true)

          if [ -n "$TASK_DEF_ARN" ] && [ "$TASK_DEF_ARN" != "None" ]; then
            echo "Task Definition ARN: $TASK_DEF_ARN"
            aws ecs describe-task-definition \
              --task-definition "$TASK_DEF_ARN" \
              --region "$AWS_REGION" \
              --query 'taskDefinition.containerDefinitions[*].{Name:name,LogConfiguration:logConfiguration}' --output json || true

            echo
            echo "=== CloudWatch log streams for log group: $LOG_GROUP ==="
            if [ -n "${STOPPED_TASKS:-}" ] && [ "${STOPPED_TASKS}" != "None" ]; then
              for arn in $STOPPED_TASKS; do
                task_id=${arn##*/}
                echo "Log streams for task $task_id:"
                aws logs describe-log-streams \
                  --log-group-name "$LOG_GROUP" \
                  --log-stream-name-prefix "$task_id" \
                  --region "$AWS_REGION" \
                  --output json || true
              done
            else
              echo "No stopped tasks to query log streams for"
            fi
          else
            echo "No taskDefinition ARN found for the service."
          fi
